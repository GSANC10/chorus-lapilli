Gabriel Sanchez
CS35L
Project log
905970079
Chorus-lapilli


                
        Upon finishing the tic tac toe app I delved into adjusting it to fit the standards of chorus lapilli. I first decided to essentially make the board function the main function of my program and as such got rid of the game function that was made in the previous tic-tac-toe app. I deleted the game function for simplicity's sake. I felt that by including it I would get confused personally and trying to sort out the history functionality with how I wanted chorus lapilli to work would just get messy. As such I also got rid of the history functionally of the game as well. However my main reason for getting rid of board was that what I was annoyed and maybe a bit lazy that I couldn’t just have everything run on basically one function and I noticed that who’s move it was and that there were functions to handle play in board that simply didn’t need to exist and were all the more confusing since they depended on history. Therefore, kicking everything out into the board function made more sense. This also meant deleting any variables that were initially passed into board so it now took no arguments. As well I kept the calculated winner function from the tic-tac-toe game and the original return statement on board. I also kept the square component function. Further, although my code is extremely clunky and could greatly benefit from helper functions, I did end up creating one that returns adjacent square’s for a given square index. Now at a broad glance, my board function handles everything else relating to the game. The bulk of my own code, deviated from the implementation of board while making tic-tac-toe, is an if else statement that is passed whoever’s turn it is. The if else statements are identical however they only differ in whether it is X’s or O’s turn and in which character is outputted into the screen. As a result I will only explain the functionality of placing X onto the board as it is identical implementation wise to putting down a O. To begin, I created five functional components to manage the state of my game. The first one I used to manage moves, the second when clicking on a tile and putting a piece down. Essentially although I changed from 0 to 1, I could have very easily made it a bool. It is just a check. The third function I used to store the previous move’s turn. The fourth to determine whos turn it was, and the fifth was to create an array of 9 tiles or essentially to manage the state of my board. I then check if we have a winner using the previously mentioned helper function, and also use split to create a new mutable array similar to squares which I will change when a player puts down a value. Now comes the bulk of my code which is in handleplay which is first passed the tile that is clicked. If there have been a total of six or more moves in the game then a set of if statements take place. First, you have to click on a tile containing the character you are playing with. In this case ‘X’. Once clicked, picked is updated to 1. However, the guard rail of splitting up the two if statements is used to ensure that I might click a square and then not like that move so I can click another and then move. Without this guardrail then the first selected square would move even though the second is the one I wanted to do. After this last square is clicked to move then pastMoves holds the element that was clicked and returns. Now ideally, we click on the spot that we want to move to. Which falls to our else statement since picked is not 0. We first check that the square we clicked is not undefined and is adjacent using pastMoves and the index of the square we clicked. This returns a bool that is either true or false and stored in a variable. Next we have an if statement that checks if there is an ‘X’ on the fourth tile. If so we then go into another if statement where if the square we clicked on is null and the previous square had an ‘X’ and moves is true meaning there are adjacent options then we put an X at this new location and clear the pastMoves position. Next we can reach another if statement that if the previous clicked square was 4 and and this move would win the game then we increment the number of moves, pass in our new board into our state function holding the board, change whos turn it is, and reset picked up to zero and return. If the new tile we didn’t click on was four of them we have an else case that checks if the square we are clicking to is null and the previous click was on an x and it is adjacent. If so we set this new square to hold and x, increment the number of moves, set the board to be updated as before, change players, and reset picked up to zero and return. If none of these cases we just return. The else part to this string of nested statements is if the move number is under 6. Therefore in this case we check that we are not clicking on an already filled square first. If we are doing so we return automatically. If not then we simply set the new square to hold X, update the board, change players, and increment the moves number. The following else statement is then if it is not X’s turn which holds the same structure as the code that I just mentioned.